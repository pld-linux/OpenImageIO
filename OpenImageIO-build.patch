--- OpenImageIO-oiio-bcdad81/src/field3d.imageio/CMakeLists.txt~	2013-11-01 18:03:46.000000000 +0100
+++ OpenImageIO-oiio-bcdad81/src/field3d.imageio/CMakeLists.txt	2013-11-05 21:12:41.033996632 +0100
@@ -1,5 +1,5 @@
 if (USE_FIELD3D)
-  if (FIELD3D_FOUND and HDF5_FOUND)
+  if (FIELD3D_FOUND AND HDF5_FOUND)
     include_directories (${FIELD3D_INCLUDES})
     add_oiio_plugin (field3dinput.cpp field3doutput.cpp
                      LINK_LIBRARIES ${FIELD3D_LIBRARY}

From 77fd2276e12791dc17cb20526cd371d66140e416 Mon Sep 17 00:00:00 2001
From: Larry Gritz <lg@larrygritz.com>
Date: Tue, 5 Nov 2013 16:05:43 -0800
Subject: [PATCH] Make cleaner threads.h compile for the NOTHREADS case

---
 src/include/thread.h | 27 ++++++++++++++++++++++-----
 1 file changed, 22 insertions(+), 5 deletions(-)

diff --git a/src/include/thread.h b/src/include/thread.h
index e389ebb..ecf3e66 100644
--- a/src/include/thread.h
+++ b/src/include/thread.h
@@ -128,6 +128,7 @@ class null_mutex {
     void unlock () { }
     void lock_shared () { }
     void unlock_shared () { }
+    bool try_lock () { return true; }
 };
 
 /// Null lock that can be substituted for a real one to test how much
@@ -219,7 +220,9 @@ class thread_specific_ptr {
 inline int
 atomic_exchange_and_add (volatile int *at, int x)
 {
-#ifdef USE_GCC_ATOMICS
+#ifdef NOTHREADS
+    int r = *at;  *at += x;  return r;
+#elif defined(USE_GCC_ATOMICS)
     return __sync_fetch_and_add ((int *)at, x);
 #elif USE_TBB
     atomic<int> *a = (atomic<int> *)at;
@@ -237,7 +240,9 @@ class thread_specific_ptr {
 inline long long
 atomic_exchange_and_add (volatile long long *at, long long x)
 {
-#ifdef USE_GCC_ATOMICS
+#ifdef NOTHREADS
+    long long r = *at;  *at += x;  return r;
+#elif defined(USE_GCC_ATOMICS)
     return __sync_fetch_and_add (at, x);
 #elif USE_TBB
     atomic<long long> *a = (atomic<long long> *)at;
@@ -261,11 +266,17 @@ class thread_specific_ptr {
 ///        *at = newval;  return true;
 ///    } else {
 ///        return false;
-///
+///    }
 inline bool
 atomic_compare_and_exchange (volatile int *at, int compareval, int newval)
 {
-#ifdef USE_GCC_ATOMICS
+#ifdef NOTHREADS
+    if (*at == compareval) {
+        *at = newval;  return true;
+    } else {
+        return false;
+    }
+#elif defined(USE_GCC_ATOMICS)
     return __sync_bool_compare_and_swap (at, compareval, newval);
 #elif USE_TBB
     atomic<int> *a = (atomic<int> *)at;
@@ -282,7 +293,13 @@ class thread_specific_ptr {
 inline bool
 atomic_compare_and_exchange (volatile long long *at, long long compareval, long long newval)
 {
-#ifdef USE_GCC_ATOMICS
+#ifdef NOTHREADS
+    if (*at == compareval) {
+        *at = newval;  return true;
+    } else {
+        return false;
+    }
+#elif defined(USE_GCC_ATOMICS)
     return __sync_bool_compare_and_swap (at, compareval, newval);
 #elif USE_TBB
     atomic<long long> *a = (atomic<long long> *)at;
-- 
1.8.4

